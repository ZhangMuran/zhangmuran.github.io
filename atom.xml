<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张暮冉的博客</title>
  
  
  <link href="https://zhangmuran.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhangmuran.github.io/"/>
  <updated>2023-07-10T16:09:17.460Z</updated>
  <id>https://zhangmuran.github.io/</id>
  
  <author>
    <name>张暮冉</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis缓存管理机制</title>
    <link href="https://zhangmuran.github.io/posts/d1b998ec.html"/>
    <id>https://zhangmuran.github.io/posts/d1b998ec.html</id>
    <published>2023-07-10T16:04:42.435Z</published>
    <updated>2023-07-10T16:09:17.460Z</updated>
    
    <content type="html"><![CDATA[<p>用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里最慢的硬件了。</p><p>当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就奔溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层。</p><p>因为 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能。</p><img src="https://s3.bmp.ovh/imgs/2023/07/10/226e6f9d09c75a2f.png" style="zoom:90%;" /><h1>保证数据库和缓存的一致性</h1><p><strong>由于引入了缓存，那么在数据更新时，不仅要更新数据库，而且要更新缓存</strong>，那么，就出现了新的问题，在数据更新时，应该先更新数据库还是先更新缓存？</p><p>我们来分析一下，考虑到<strong>并发</strong>问题，比如「请求 A 」和「请求 B 」两个请求，同时更新「同一条」数据，则可能出现这样的顺序：</p><img src="https://s3.bmp.ovh/imgs/2023/07/10/cc320f7175e469d4.webp" style="zoom: 67%;" /><p>A 请求先将数据库的数据更新为 1，然后在更新缓存前，请求 B 将数据库的数据更新为 2，紧接着也把缓存更新为 2，然后 A 请求更新缓存为 1。</p><p>此时，数据库中的数据是 2，而缓存中的数据却是 1，<strong>出现了缓存和数据库中的数据不一致的现象</strong>。</p><p>反过来，这次我们<strong>先更新缓存，后更新数据库</strong></p><p>可以发现，依然会出现缓存和数据库中数据不一致的情况</p><img src="https://s3.bmp.ovh/imgs/2023/07/10/dc56badbff3726ae.webp" style="zoom:67%;" /><p>所以，<strong>无论是「先更新数据库，再更新缓存」，还是「先更新缓存，再更新数据库」，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象</strong>。</p><p>这次换个思路，数据发生变化时，<strong>不更新缓存，而是删除缓存中的数据。然后，到读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。</strong></p><p>出于对刚刚问题的拓展，我们是<strong>先更新数据库还是先更新缓存</strong>呢？</p><p>假设先删除缓存。删除缓存后在数据库更新之前来了一发查询，结果空缓存又读取上了数据库的值，随后我们更新了数据库。相当于删除缓存的动作被省略了，发生了缓存和数据库中的数据不一致</p><img src="https://s3.bmp.ovh/imgs/2023/07/10/29dae5624e1496ec.webp" style="zoom:67%;" /><p>接下来考虑先更新数据库</p><p>假如某个用户数据在缓存中不存在，从数据库读取数据写入缓存之前发生了更新数据库，删除缓存的过程，又导致了不一致的结果</p><img src="https://s3.bmp.ovh/imgs/2023/07/10/10aaec64c6a9e712.webp" style="zoom: 67%;" /><p>从上面的理论上分析，先更新数据库，再删除缓存也是会出现数据不一致性的问题，<strong>但是在实际中，这个问题出现的概率并不高</strong>。</p><p><strong>因为缓存的写入通常要远远快于数据库的写入</strong>，所以在实际中很难出现请求 B 已经更新了数据库并且删除了缓存，请求 A 才更新完缓存的情况。</p><p>所以，<strong>「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的</strong>。</p><p>为了确保万无一失，还可以给缓存数据加上「<strong>过期时间</strong>」，就算在这期间存在缓存数据不一致，有过期时间来兜底，这样也能达到最终一致。</p><p>引入了缓存层，就会有缓存异常的三个问题，分别是<strong>缓存雪崩、缓存击穿、缓存穿透</strong></p><h1>缓存雪崩</h1><p>为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间。当缓存数据过期后，需要重新访问数据库生成缓存，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。</p><p>那么，当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong>的问题。</p><img src="https://s3.bmp.ovh/imgs/2023/07/10/715e8458a04cf357.png" style="zoom: 50%;" /><p>为了<strong>防止大量缓存数据在同一时间过期</strong>，可以：</p><ul><li><p><strong>均匀设置过期时间</strong></p><p>可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p></li><li><p><strong>互斥锁</strong></p><p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p><p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，避免请求发生了某种意外而一直阻塞，导致其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p></li><li><p><strong>后台更新缓存</strong></p></li></ul><p>除此之外，<strong>Redis故障宕机</strong>也会导致缓存雪崩，我们可以：</p><ul><li><p>服务熔断或请求限流机制</p><p>启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，不用再继续访问数据库，从而降低对数据库的访问压力，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p><p>服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作</p><p>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制</p></li><li><p>构建 Redis 缓存高可靠集群</p><p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p><p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p></li></ul><h1>缓存击穿</h1><p>我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。</p><p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p><p>缓存击穿跟缓存雪崩很相似，可以认为缓存击穿是缓存雪崩的一个子集。</p><p>应对缓存击穿可以采取前面说到两种方案：</p><ul><li>互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间</li></ul><h1>缓存穿透</h1><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p><img src="https://s3.bmp.ovh/imgs/2023/07/10/9bae65e30b107998.png" style="zoom:50%;" /><p>应对缓存穿透的方案，常见的方案有三种。</p><ul><li><p>非法请求的限制</p><p>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p></li><li><p>缓存空值或者默认值</p><p>当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库</p></li><li><p>使用<strong>布隆过滤器</strong>快速判断数据是否存在，避免通过查询数据库来判断数据是否存在</p><p>我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。</p><p>即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p></li></ul><h1>总结</h1><img src="https://s3.bmp.ovh/imgs/2023/07/10/797959df0f34c29f.webp" style="zoom: 67%;" />]]></content>
    
    
    <summary type="html">关于缓存雪崩、击穿、穿透以及如何实现数据库和缓存一致性</summary>
    
    
    
    <category term="数据库" scheme="https://zhangmuran.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://zhangmuran.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis常见数据类型</title>
    <link href="https://zhangmuran.github.io/posts/ad7e0bd5.html"/>
    <id>https://zhangmuran.github.io/posts/ad7e0bd5.html</id>
    <published>2023-07-10T14:19:44.352Z</published>
    <updated>2023-07-10T14:40:01.815Z</updated>
    
    <content type="html"><![CDATA[<h1>基本命令</h1><p><code>keys *</code> 查看当前库中有哪些 key</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;users&quot;</span><br></pre></td></tr></table></figure><p><code>exists key</code> 判断某个 key 是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists users</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; exists user</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p><code>type key</code> 查看 key 对应的数据类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; type users</span><br><span class="line">hash</span><br></pre></td></tr></table></figure><p><code>del key</code> 和 <code>unlink key</code> 都是删除指定的 key 数据。区别在于del key是直接删除，而 <code>unlink key</code> 是将key 从 keyspace元数据中删除，真正的删除会在后续异步操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del key1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; unlink key2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><code>expire key seconds</code> 为key设置指定的过期时间，可以使用 <code>ttl key</code> 查看 key 还有多久过期，-1 代表永不过期，-2 代表已经过期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">127.0.0.1:6379&gt; ttl key1</span><br><span class="line">(integer) -1</span><br><span class="line">127.0.0.1:6379&gt; expire key1 10</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl key1</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; ttl key1</span><br><span class="line">(integer) -2</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br></pre></td></tr></table></figure><p><code>select index</code> 可以切换数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[2]&gt; select 0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><code>dbsize</code> 查看当前数据库中key的数量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><code>flushdb</code> 和 <code>flushall</code> 分别代表清空当前数据库和清空所有数据库</p><h1>字符串 String</h1><p>String是Redis最基本的类型，一个key对应一个value。String类型是<strong>二进制安全</strong>的。意味着Redis的String可以包含任何数据。比如jpg图片或者序列化的对象。String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是<strong>512M</strong></p><p><code>set key value [expiration EX seconds|PX milliseconds] [NX|XX]</code> 来添加String类型的键值对，重复对一个key操作会覆盖value</p><p><code>get key</code> 查询对应键值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 value1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;value1&quot;</span><br></pre></td></tr></table></figure><p><code>append key value</code> 为key对应的字符串后追加value</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; append key1 abc</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">&quot;value1abc&quot;</span><br></pre></td></tr></table></figure><p><code>strlen key</code> 获取对应字符串的长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; strlen key1</span><br><span class="line">(integer) 9</span><br></pre></td></tr></table></figure><p><code>setnx key value</code> 只有在key不存在时，才能成功设置key的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setnx key2 value2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>如果对应的value是<strong>数字类型</strong>，则可以使用 <code>incr key</code> 和 <code>decr key</code> 来为对应的数字加一和减一</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incr key1</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br><span class="line">127.0.0.1:6379&gt; set num 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(integer) 101</span><br><span class="line">127.0.0.1:6379&gt; decr num</span><br><span class="line">(integer) 100</span><br></pre></td></tr></table></figure><p>如果要指定步长，则可用 <code>incrby key increment</code>  以及 <code>decrby key increment</code> 指定步长对数字加减操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incrby num 100</span><br><span class="line">(integer) 200</span><br><span class="line">127.0.0.1:6379&gt; decrby num 300</span><br><span class="line">(integer) -100</span><br></pre></td></tr></table></figure><p><code> mset key value [key value ...]</code>  <code> mget key [key ...]</code> <code>msetnx key value [key value ...]</code> 三个命令分别对应 <code>set</code> <code>get</code> <code>setnx</code> ，区别在一次可以操作多个键值对，需要注意<code>msetnx</code> 只有所有的key都不存在时才会成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) (nil)</span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k3 v3</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) (nil)</span><br><span class="line">127.0.0.1:6379&gt; msetnx k3 v3 k4 v4</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; mget k3 k4</span><br><span class="line">1) &quot;v3&quot;</span><br><span class="line">2) &quot;v4&quot;</span><br></pre></td></tr></table></figure><p><code>getrange key start end</code> 拿字符串上的指定区间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">&quot;helloworld&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 0 4</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">127.0.0.1:6379&gt; getrange key 0 100</span><br><span class="line">&quot;helloworld&quot;</span><br></pre></td></tr></table></figure><p><code>setrange key offset value</code> 从指定偏移量开始设置字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setrange key 12 abc</span><br><span class="line">(integer) 15</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">&quot;helloworld\x00\x00abc&quot;</span><br></pre></td></tr></table></figure><p><code>setex key seconds value</code> 设置键值对同时设置过期时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex key 10 value</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><h1>列表 List</h1><p>单键多值。<br>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部(左边）或者尾部(右边)。·<br>它的底层实际是个<strong>双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><p><code>lpush key value [value ...]</code> 和 <code>rpush key value [value ...]</code> 分别表示从左边和右边向列表key中放入数据（压栈）</p><p><code>lpop key</code> 和 <code>rpop key</code> 分别表示从列表key中弹出左边或者右边的元素</p><p><code>lrange key start stop</code> 从左边顺序查看列表中元素，stop为-1表示到倒数第一个元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush list v1 v2 v3 v4 v5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;v5&quot;</span><br><span class="line">2) &quot;v4&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">4) &quot;v2&quot;</span><br><span class="line">5) &quot;v1&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line">&quot;v5&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;v4&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">4) &quot;v1&quot;</span><br></pre></td></tr></table></figure><p><code>lindex key index</code> 获取从左往右下标第index的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lindex list 1</span><br><span class="line">&quot;v3&quot;</span><br></pre></td></tr></table></figure><p><code>llen key</code> 获取列表的长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><p><code>linsert key BEFORE|AFTER pivot value</code> 在列表key中找到从左开始找到第一个pivot并在其 之前/之后 插入value</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; linsert list BEFORE v2 v22</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;v4&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v22&quot;</span><br><span class="line">4) &quot;v2&quot;</span><br><span class="line">5) &quot;v1&quot;</span><br></pre></td></tr></table></figure><p><code>lrem key count value</code> 从左边开始删除count个value</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrem list 2 v22</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;v4&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">4) &quot;v1&quot;</span><br></pre></td></tr></table></figure><p><code>lset key index value</code> 将列表key下表index的元素替换为value</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lset list 1 hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) &quot;v4&quot;</span><br><span class="line">2) &quot;hello&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">4) &quot;v1&quot;</span><br></pre></td></tr></table></figure><h1>集合 Set</h1><p>Redis Set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，Set是一个很好的选择，并且Set提供了判断某个成员是否在一个Set集合内的重要接口，这个也是list所不能提供的。<br>Redis的Set是String类型的<strong>无序集合</strong>。它底层其实是一个value为null的hash表，所以添加，删除，查找的复杂度都是 <strong>O(1)</strong>。</p><p><code>sadd key member [member ...]</code> 向集合中添加元素</p><p><code>smembers key</code> 取出该集合的所有值</p><p><code>scard key</code> 返回该集合中的元素的个数</p><p><code>srem key member [member ...]</code> 删除集合中的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set k1 k2 k2 k3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers set</span><br><span class="line">1) &quot;k1&quot;</span><br><span class="line">2) &quot;k3&quot;</span><br><span class="line">3) &quot;k2&quot;</span><br><span class="line">127.0.0.1:6379&gt; scard set</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; srem set k3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers set</span><br><span class="line">1) &quot;k1&quot;</span><br><span class="line">2) &quot;k2&quot;</span><br></pre></td></tr></table></figure><p><code>spop key [count]</code>  从集合中<strong>随机</strong>弹出count个元素，默认一个</p><p><code>srandmember key [count]</code> 从集合中<strong>随机</strong>取出count个元素</p><p><code>smove source destination member</code> 把集合source中的member转移到destination中</p><p><code>sinter key [key ...]</code> 返回集合中的交集</p><p><code>sunion key [key ...]</code> 返回集合中的并集</p><p><code>sdiff key [key ...]</code> 返回集合中的差集，a中有，b中没有</p><h1>哈希 Hash</h1><p>Redis Hash是一个键值对集合。<br>Redis Hash是一个String类型的 field和value的映射表，Hash 特别适合用于存储对象。</p><p><code>hset key field value</code> 设置哈希key的field字段为value，可以用 <code>hmset key field value [field value ...]</code> 批量操作</p><p><code>hget key field</code> 获取field字段下的值，用 <code>hmget key field [field ...]</code> 批量操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user name zmr age 18</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget user name age</span><br><span class="line">1) &quot;zmr&quot;</span><br><span class="line">2) &quot;18&quot;</span><br></pre></td></tr></table></figure><p><code>hexists key field</code> 查看哈希表中key下是否有field</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists user age</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><code>hkeys key</code> 查看key下的所有field</p><p><code>hvals key</code> 查看key下的所有values</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys user</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals user</span><br><span class="line">1) &quot;zmr&quot;</span><br><span class="line">2) &quot;18&quot;</span><br></pre></td></tr></table></figure><p><code>hincrby key field increment</code> 给field的数字值加increment</p><p><code>hsetnx key field value</code> 不重复的field才可以加</p><h1>有序集合 Zset</h1><p>Redis有序集合Zset与普通集合Set非常相似，是一个<strong>没有重复元素</strong>的字符串集合。不同之处是有序集合的每个成员都关联了一个评分(score) ,这个评分 (score)被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了。<br>因为元素是有序的,所以你也可以很快的根据评分(score)或者次序(position)来获取一个范围的元素。<br>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><p><code>zadd key [NX|XX] [CH] [INCR] score member [score member ...]</code> 将一个或多个元素的值以及其评分加入Zset</p><p><code>zrange key start stop [WITHSCORES]</code> 返回有序的Zset指定下标的元素，如果有WITHSCORES，则会显示评分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd topn 100 c++ 50 java 150 go 10 php</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; zrange topn 0 -1 WITHSCORES</span><br><span class="line">1) &quot;php&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;50&quot;</span><br><span class="line">5) &quot;c++&quot;</span><br><span class="line">6) &quot;100&quot;</span><br><span class="line">7) &quot;go&quot;</span><br><span class="line">8) &quot;150&quot;</span><br></pre></td></tr></table></figure><p><code>zrangebyscore key min max [WITHSCORES] [LIMIT offset count]</code> 返回评分介于 min 和 max 的元素，从小到大。<code>zrevrangebyscore key max min [WITHSCORES] [LIMIT offset count]</code> 则为从大到小</p><p><code>zincrby key increment member</code> 为元素member的score加上increment</p><p><code>zrem key member [member ...]</code> 删除元素member</p><p><code>zcount key min max</code> 返回分数区间内的元素个数</p><p><code>zrank key member</code> 返回该值在集合中的排名，从0开始</p><h1>事务和锁</h1><p>Redis事务是一个单独的隔离操作︰事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><h2 id="Milti-Exex-Discard">Milti Exex Discard</h2><p>使用 <code>multi</code> 开始组队，随后写入redis命令，完成后 <code>exec</code> 便开始执行命令，<code>discard</code> 则放弃执行</p><img src="https://s3.bmp.ovh/imgs/2023/07/08/3911a9917cc66370.png" style="zoom:50%;" /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; discard</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2 id="错误处理">错误处理</h2><p>如果在组队的过程中发生了错误，那么所有的命令都无法正常的执行</p><img src="https://s3.bmp.ovh/imgs/2023/07/08/83bc2c133f92b01a.png" style="zoom:50%;" /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;set&#x27; command</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure><p>如果在执行的过程中出错，那么只有失败的命令无法正常执行，其他的命令都会执行</p><img src="https://s3.bmp.ovh/imgs/2023/07/08/b35ab92d5ad19c5e.png" style="zoom:50%;" /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an integer or out of range</span><br><span class="line">3) OK</span><br></pre></td></tr></table></figure><h2 id="事务冲突">事务冲突</h2><p>可以用<strong>乐观锁</strong>来解决，在执行 <code>multi</code> 之前，先执行 <code>watch key1 [key...]</code> ，可以监视一个(或多个) key，如果在事务执行之前这个(或这些) key被其他命令所改动，那么事务将被打断。</p><p>用两个客户端来演示一下，现在有String类型的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 100</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>两个客户端都对k1进行watch，并且执行事务对k1进行操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch k1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decrby k1 10</span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure><p>此时一个客户端率先执行exec</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (integer) 90</span><br></pre></td></tr></table></figure><p>另外一个在进行操作，就会收到乐观锁的限制执行失败</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h1>持久化</h1><p>Redis 是一种基于内存的数据库，所有的数据都存储在内存中。但是也有办法把数据放到磁盘中，这个过程就叫做持久化</p><h2 id="RDB">RDB</h2><p>在指定的<strong>时间间隔</strong>内将内存中的数据集<strong>快照</strong>写入磁盘，也就是行话讲的 Snapshot快照，它恢复时是将快照文件直接读到内存里。</p><h2 id="AOF">AOF</h2><p>AOF和RDB同时开启，系统默认读取AOF中的数据</p><h1>主从复制</h1><h1>集群</h1>]]></content>
    
    
    <summary type="html">String,List,Hash,Set,Zset</summary>
    
    
    
    <category term="数据库" scheme="https://zhangmuran.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://zhangmuran.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>HTTP版本变化</title>
    <link href="https://zhangmuran.github.io/posts/0.html"/>
    <id>https://zhangmuran.github.io/posts/0.html</id>
    <published>2023-07-03T15:29:03.000Z</published>
    <updated>2023-07-03T15:50:18.382Z</updated>
    
    <content type="html"><![CDATA[<h1>HTTP/1.1</h1><p>HTTP/1.1 相比 HTTP/1.0 性能上的改进：</p><ul><li>使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li><li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>但 HTTP/1.1 还是有性能瓶颈：</p><ul><li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ul>]]></content>
    
    
    <summary type="html">由浅入深学习HTTP和HTTPS</summary>
    
    
    
    <category term="计算机网络" scheme="https://zhangmuran.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="https://zhangmuran.github.io/tags/HTTP/"/>
    
    <category term="HTTPS" scheme="https://zhangmuran.github.io/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>HTTP基础</title>
    <link href="https://zhangmuran.github.io/posts/22f97770.html"/>
    <id>https://zhangmuran.github.io/posts/22f97770.html</id>
    <published>2023-07-03T14:35:03.000Z</published>
    <updated>2023-07-03T15:26:25.734Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP 是超文本传输协议，也就是 <strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p><h1>HTTP基本概念</h1><h2 id="HTTP报文结构">HTTP报文结构</h2><p>HTTP的请求报文由四部分组成：请求行(request line)、请求头部(header)、空行和请求数据(request data)</p><p><img src="https://s3.bmp.ovh/imgs/2023/07/02/0f05d854449273d7.png" alt=""></p><p>HTTP响应报文由状态行(status line)、响应头部(headers)、空行(blank line)和响应数据(response body)四个部分组成</p><p><img src="https://s3.bmp.ovh/imgs/2023/07/02/a443ac90965d23e7.png" alt=""></p><h2 id="HTTP常见状态码">HTTP常见状态码</h2><img src="https://s3.bmp.ovh/imgs/2023/07/02/781699fdddba25f5.webp" width="80%" height="80%" /><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li></ul><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p><ul><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h2 id="HTTP-常见字段">HTTP 常见字段</h2><ul><li><p><em>Host</em> 字段</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.baidu.com</span><br></pre></td></tr></table></figure></li><li><p><em>Content-Length 字段</em></p><p>HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，<strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong>。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1000</span><br></pre></td></tr></table></figure></li><li><p><em>Connection 字段</em></p><p><code>Connection</code> 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。</p><p>HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p>HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br></pre></td></tr></table></figure><p>开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。</p></li><li><p><em>Content-Type 字段</em></p><p><code>Content-Type</code> 字段用于服务器<strong>回应</strong>时，告诉客户端，本次数据是什么格式。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; Charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br></pre></td></tr></table></figure><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p></li><li><p><em>Content-Encoding 字段</em></p><p><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br></pre></td></tr></table></figure><p>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</p><p>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br></pre></td></tr></table></figure></li></ul><h1>GET 和 POST</h1><p><strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。</p><p><strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</p><blockquote><p>GET 和 POST 方法都是安全和幂等的吗？</p></blockquote><ul><li>「安全」是指请求方法不会「破坏」服务器上的资源。</li><li>「幂等」是多次执行相同的操作，结果都是「相同」的。</li></ul><p>从 RFC 规范定义的语义来看：</p><ul><li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li><li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li></ul><p>但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：</p><ul><li>可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。</li><li>可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。</li></ul><h1>HTTP缓存</h1><p>对于一些具有重复性的 HTTP 请求，每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<strong>缓存在本地</strong>，那么下次就直接读取本地的数据，不必再通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。</p><p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p><h2 id="强制缓存">强制缓存</h2><p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p><img src="https://s3.bmp.ovh/imgs/2023/07/02/5c0336f4665703d2.webp" style="zoom: 33%;" /><p>强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：</p><ul><li><code>Cache-Control</code>， 是一个相对时间</li><li><code>Expires</code>，是一个绝对时间</li></ul><p>如果同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong> 。</p><p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小。再次请求访问该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器。服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</p><h2 id="协商缓存">协商缓存</h2><p><strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。</p><img src="https://s3.bmp.ovh/imgs/2023/07/02/ccfd0648f8505dfd.webp" style="zoom:50%;" /><p>协商缓存可以基于两种头部来实现。</p><p>第一种：请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p><ul><li>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</li><li>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新，说明资源又被改过，则返回最新资源，<strong>HTTP 200 OK</strong>；如果最后修改时间较旧，说明资源无新修改，响应 <strong>HTTP 304</strong> ，不返回资源走缓存。</li></ul><p>第二种：请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p><ul><li>响应头部中 <code>Etag</code>：唯一标识响应资源；</li><li>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 <strong>304</strong>，如果资源变化了返回 <strong>200</strong>。</li></ul><blockquote><p>第二种方式优先级更高，可以想一下为什么</p></blockquote><p><strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><img src="https://s3.bmp.ovh/imgs/2023/07/02/26681768449a00ef.webp" style="zoom:50%;" /><h1>HTTP特性</h1><h1>HTTPS</h1><p>HTTP 信息是明文传输，TCP 三次握手之后便可进行 HTTP 的报文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，使得报文能够加密传输。</p><p>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li><li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li><li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li></ul><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p><ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul><p>可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的。</p><h2 id="HTTPS如何解决HTTP的问题">HTTPS如何解决HTTP的问题</h2><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>消息认证码，数字签名</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul><h3 id="混合加密">混合加密</h3><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul><p>采用「混合加密」的方式的原因：</p><ul><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul><h3 id="消息认证码">消息认证码</h3><p>为了保证传输的内容不被篡改，我们需要对内容做哈希操作得到消息认证码，然后将消息认证码同内容一起传输给对方。</p><p>对方收到内容和消息认证码后，先是重新对内容计算出一个消息认证码，然后跟发送方发送的消息认证码做比较，如果相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。</p><h3 id="数字签名">数字签名</h3><p>通过哈希算法可以确保内容不会被篡改，<strong>但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。这种情况还可能造成<strong>事后否认</strong></p><p>为了避免这种情况，计算机里会用<strong>非对称加密算法</strong>来解决，</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul><p>在数字签名这里，我们自然要使用<strong>私钥加密，公钥解密</strong></p><p>这样凡是可以用发送方提供的公钥解开的数字签名，就可以说明该信息一定是由公钥的提供者发送的，避免了<strong>假冒</strong>的出现</p><h3 id="数字证书">数字证书</h3><p>在非对称加密的过程中，需要先发送公钥给对方。如果这个公钥是第三方发送的呢。为了解决这个问题，就需要数字证书。</p><p>颁发数字证书的权威机构就是 CA （数字证书认证机构），CA将服务器公钥和由CA的私钥生成的数字签名放在数字证书中。这样数字证书中不仅包含了服务器的公钥，又可以通过数字签名保证数字证书一定是CA发布的而并非第三方伪造。于是就可以安全的拿到服务器的公钥进行对称加密了。</p><p>同时为了防止第三方篡改数字证书的内容以及CA的公钥，CA的上级还有更高级CA为其提供数字证书来防止这种情况，一直到最高级的几个RCA再互相提供数字证书，形成了规模庞大的CA链，这大大提高了第三方的难度和成本。</p><h2 id="HTTPS建立连接的过程">HTTPS建立连接的过程</h2><p>在完成了TCP三次握手之后，会进行SSL/TLS 的建立过程，也就是 TLS 握手阶段。</p><p>TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA 算法和 ECDHE 算法。</p><p>这里说一下比较简单的基于RSA算法的的TLS握手。</p>]]></content>
    
    
    <summary type="html">由浅入深学习HTTP和HTTPS</summary>
    
    
    
    <category term="计算机网络" scheme="https://zhangmuran.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="HTTP" scheme="https://zhangmuran.github.io/tags/HTTP/"/>
    
    <category term="HTTPS" scheme="https://zhangmuran.github.io/tags/HTTPS/"/>
    
  </entry>
  
</feed>
